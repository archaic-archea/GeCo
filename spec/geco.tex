\documentclass[6pt]{article}

\def\version{0.1 Rev 2.0}
\def\name{Germanium Core}
\def\sname{GeCo}

\usepackage{tabularx}

\title{\name}
\author{Lilly Anderson}

\begin{document}
\maketitle

\pagebreak
\tableofcontents

\pagebreak
\addcontentsline{toc}
{section}{Introduction}
\section*{Introduction}
This is the \sname\ (\name) architectural specification v\version. This gives information on the hardware expectations of a valid \sname\ implementation.

\subsection{Goals}
\begin{itemize}
    \item Symmetric Multi-Processing
    \item Variable instruction length (16, 32, and 64 bit sizes)
    \item Software managed address translation
    \item Memory mapped IO
\end{itemize}

\section{16 Bit Encodings}
This section describes compressed instruction encodings for \sname\ to help reduce binary sizes. We will use "CGC" to refer to 16 bit encodings in general.

\subsection{Overview}
CGC is used to compress a few different kinds of instructions, specifically common types of instructions, such as stack, thread, and global relative accesses, loading immediates, arithmetic operations, jumping, and branching. It supports 4 different encodings.
\begin{itemize}
    \item RelIAcc Encoding, handles relative accesses for the SP, TP, and GP registers with an offset from an immediate
    \item ARAcc Encoding, handles Arithmetic accesses between 2 registers
    \item AIAcc Encoding, handles Arithmetic accesses with 1 register and an immediate,
    \item Ctrl Encoding, priviledged instructions for processor control, provides 1 register
\end{itemize}
\subsection{RelIAcc}
The RelIAcc encoding handles relative memory accesses using an immediate as offset.

\begin{center}
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Instruction mneumonic & Use & Format \\
    \hline
    cgc.lb & Loads 1 byte & cgc.lb rd, imm(ra) \\
    \hline
    cgc.ld & Loads 2 bytes & cgc.ld rd, imm(ra) \\
    \hline
    cgc.lq & Loads 4 bytes & cgc.lq rd, imm(ra) \\
    \hline
    cgc.lo & Loads 8 bytes & cgc.lo rd, imm(ra) \\
    \hline
    cgc.sb & Stores 1 byte & cgc.sb rs, imm(ra) \\
    \hline
    cgc.sd & Stores 2 bytes & cgc.sd rs, imm(ra) \\
    \hline
    cgc.sq & Stores 4 bytes & cgc.sq rs, imm(ra) \\
    \hline
    cgc.so & Stores 8 bytes & cgc.so rs, imm(ra) \\
    \hline
\end{tabularx}
\end{center}

\begin{center}
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Bit range (inclusive) & Name & Abbreviation \\
    \hline
    0..1 & Encoding Size & n/a \\
    \hline
    2..4 & Opcode & n/a \\
    \hline
    5..6 & Address IDR & ra \\
    \hline
    7..9 & Source/Destination HGP Register & rs/rd \\
    \hline
    10..15 & Immediate Offset & imm \\
    \hline
\end{tabularx}
\end{center}

\begin{center}
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Opcode & Instruction \\
    \hline
    0b000 & cgc.lb \\
    \hline
    0b001 & cgc.ld \\
    \hline
    0b010 & cgc.lq \\
    \hline
    0b011 & cgc.lo \\
    \hline
    0b100 & cgc.sb \\
    \hline
    0b101 & cgc.sd \\
    \hline
    0b110 & cgc.sq \\
    \hline
    0b111 & cgc.so \\
    \hline
\end{tabularx}
\end{center}

\section{32 Bit Encodings}

\section{64 Bit Encodings}

\section{Instructions}

\section{Registers}
The \sname\ processors support 31 different general purpose registers, and 1 register doubling as a scratch, and no-access register. There are also 256 CSR (Control/Status Register) addresses.

\subsection{Definitions}
\begin{center}
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Term & Read & Write \\
    \hline
    AA & Any & Any \\
    \hline
    AI & Any & Ignored \\
    \hline
    AL & Any & Legal \\
    \hline
\end{tabularx}
\end{center}

\subsection{Main Registers}
Main registers are intended to be used for general processing.
\begin{center}
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Register ID & Name & Use \\
    \hline
    0b00000 & Zero/Scratch & Will read zero\footnotemark[1]\\
    \hline
    0b00001 & Stack base & Start of the stack in memory \\
    \hline
    0b00010 & Return address & Stores where to return to after a jump \\
    \hline
    0b00011 & Frame pointer (IDR0) & Points to the start of the frame \\
    \hline
    0b00100 & Stack pointer (IDR0) & Current position in the stack \\
    \hline
    0b00101 & Global pointer (IDR0) & Points to the global storage region \\
    \hline
    0b00110 & Thread pointer (IDR0) & Points to the thread storage region \\
    \hline
    0b00111-0b01111 & hgp0-hgp7 & High access general purpose, used in cgc \\
    \hline
    0b10000-0b11111 & gp0-gp16 & General purpose, any use \\
    \hline
    \footnotetext[1]{It can be read/write if the trap bit in the processor flags is set, it's state must be consistent accross traps}
\end{tabularx}
\end{center}

\subsection{Control/Status Registers}
Contro/Status Registers are used to control aspects of the processor, or query the status of different parts of the processor.

\subsubsection{CSR Listing}
\begin{center}
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Address & Bits & Name & Access & Minimum Mode & Section \\
    \hline
    0x000000 & 64 & scause & AA & Supervisor & 6.2 \\
    \hline
    0x000001 & 64 & strap & AA & Supervisor & 6.2 \\
    \hline
    0x000002 & 64 & sret & AA & Supervisor & 6.2 \\
    \hline
    0x000003 & 64 & sscratch & AA & Supervisor & 6.2 \\
    \hline
    0x010000 & 64 & memmode & AA & Supervisor & 7 \\
    \hline
    0x010014 & 64 & memreg & AA & Supervisor & 7 \\
    \hline
\end{tabularx}
\end{center}

\section{Traps}
On a GeCo system traps serve to help handle internal errors, and external devices.

\subsection{Overview}
To provide proper access to external devices, and internal error handling, GeCo provides traps as they come in. These traps can occur due to several reasons, and can be mapped to different values.
\begin{center}
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Source & Number & Reason \\
    \hline
    External (1) & 0x00 & MSI \\
    External (1) & 0x02 & Timer \\
    External (1) & 0x04 & External device \\
    \hline
    Internal (0) & 0x00 & Misaligned instruction \\
    Internal (0) & 0x02 & Misaligned read \\
    Internal (0) & 0x04 & Misaligned write \\
    Internal (0) & 0x06 & Invalid instruction address \\
    Internal (0) & 0x08 & Invalid read address \\
    Internal (0) & 0x0A & Invalid write address \\
    Internal (0) & 0x0C & Instruction page fault \\
    Internal (0) & 0x0E & Read page fault \\
    Internal (0) & 0x10 & Write page fault \\
    \hline
\end{tabularx}
\end{center}

\subsection{CSRs}
To allow for changing the device's state for traps there are several CSRs provided by GeCo. These CSRs can manage the trap handler address, the trap cause, the MSI source, and return address.

\subsubsection{strap}
Supervisor trap, or "strap", is a CSR used to control the virtual address of the trap handler, if virtual addressing is disabled then this address will be treated as physical.

\begin{center}
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Bit(s) & Name & Use \\
    \hline
    0..62 & Strap Vaddr & Lower 63 bits of the trap handler's address \\
    \hline
    63 & Strap On & Enables trapping\footnotemark[1] \\
    \hline
\end{tabularx}
\end{center}
\footnotetext[1]{If a trap occurs and the strap.on bit is not set, then the core may repeatedly trap until powered down, halt execution but remain powered on, or it can power down that core, if every core in a chip is powered down then the entire system must power down. Regardless of if it shuts the core down, if other cores exist the CCD (specified in 7.3) must be notified}

\subsection{Core Communication Device}
The CCD (Core Communication Device) can be used to alert other cores of new events, this acts similarly to an MSI but may be implicitly triggered by the processor, or may have implicit reactions.
This device can be used to send IPIs, send remote fences, and change the state of other cores.

\subsubsection{Layout}
The CCD provides different regions, each region contains registers used for controlling the other cores, or the local core. It is split into 2 regions, the Core Control region (CCR), and the Core Local Buffer region (CLB).
The CCR must always be provided at physical address 0x2000, and take up 0x2000 bytes. The CLB must be provided at physical address 0x1000, and take up 0x1000 bytes.
\begin{center}
Core Control Region Layout
\begin{tabularx}{\textwidth}{ |>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X| }
    \hline
    Byte & Size & Name & Use \\
    \hline
    0x0 & 2 & Core 0 Control & Used to send a signal to the core\footnotemark[1] \\
    \hline
    ... & ... & ... & ... \\
    \hline
    0x1FF8 & 2 & Core 4095 Control & Used to send a signal to the core\footnotemark[1] \\
    \hline
\end{tabularx}
\end{center}
\footnotetext[1]{If a core is not associated with that register, nothing should happen}

\section{Virtual Addressing}

\end{document}